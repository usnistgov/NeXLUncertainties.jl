<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting Started · NeXLUncertainties.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link rel="stylesheet" href="https://pages.nist.gov/nist-header-footer/css/nist-combined.css">
<script src="https://pages.nist.gov/nist-header-footer/js/jquery-1.9.0.min.js" type="text/javascript" defer="defer"></script>
<script src="https://pages.nist.gov/nist-header-footer/js/nist-header-footer.js" type="text/javascript" defer="defer"></script>
</head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="NeXLUncertainties.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">NeXLUncertainties.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Getting Started</a><ul class="internal"><li><a class="tocitem" href="#Getting-Started-with-NeXLUncertainies.jl"><span>Getting Started with NeXLUncertainies.jl</span></a></li></ul></li><li><a class="tocitem" href="../composing/">Composing Multi-Step Models</a></li><li><a class="tocitem" href="../resistors/">Resistor Network Example</a></li><li><a class="tocitem" href="../methods/">Methods</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Getting Started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting Started</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/usnistgov/NeXLUncertainties.jl/blob/master/docs/src/gettingstarted.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Getting-Started-with-NeXLUncertainies.jl"><a class="docs-heading-anchor" href="#Getting-Started-with-NeXLUncertainies.jl">Getting Started with NeXLUncertainies.jl</a><a id="Getting-Started-with-NeXLUncertainies.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-Started-with-NeXLUncertainies.jl" title="Permalink"></a></h2><p>Uncertainty calculations can separated into univariate and multivariate cases depending upon the number of <strong>output</strong> quantities.  The univariate case is often handled using the strategies described in <em><a href="https://www.bipm.org/en/publications/guides/gum.html">JCGM GUM 100 - Guide to the Expression of Uncertainty in Measurement</a></em> and presented in many an undergraduate science class.  This technique can track uncertainties in multiple input quantities into the output value.  This strategy is well implemented in the <a href="https://github.com/JuliaPhysics/Measurements.jl">Measurements.jl</a> package.</p><p>However, if your problem involves multiple outputs from one or more inputs, there will be correlations in the outputs that aren&#39;t handled in the univariate case.  X-ray microanalysis is an example of such a measurement model.  The inputs are k-ratios, ratios of X-ray intensity measured on a known and unknown material.  The outputs are the mass fractions of each element.  You can&#39;t measure one element at a time.  You must measured them all because the k-ratio for element A is a function of all the other elements in the material due to &quot;matrix effects&quot;. So the mass fraction of element <span>$C_i$</span> is actually a function of all the <span>$k$</span>s.</p><p>The multivariate case can be handled using strategies in <a href="https://www.bipm.org/utils/common/documents/jcgm/JCGM_101_2008_E.pdf">JCGM GUM 101 - Evaluation of measurement data — Supplement 1 to the “Guide to the expression of uncertainty in measurement” — Propagation of distributions using a Monte Carlo method</a> or <a href="https://www.bipm.org/utils/common/documents/jcgm/JCGM_102_2011_E.pdf">JCGM GUM 102 - Evaluation of measurement data – Supplement 2 to the &quot;Guide to the expression of uncertainty in measurement&quot; – Extension to any number of output quantities</a>.</p><p>There isn&#39;t another library to handle the multivariate case, so this is it.</p><p>This library defines two structures to hold quantities with associated uncertainties. A single value with an associate uncertainty is represented by an <code>UncertainValue</code>.  Multiple values, their uncertainties and the correlations between the values are represented by an <code>UncertainValues</code> (plural) structure. Internally, an <code>UncertainValues</code> object is represented by a <code>Vector{Float64}</code> and the covariance matrix by a <code>Matrix{Float64}</code>.</p><p>Often, the inputs to a calculation are represented by <code>UncertainValue</code> objects, while the calculation is progressing the values are tracked using <code>UncertainValues</code> objects and at the end of the calculation, the result is best expressed as an <code>UncertainValues</code> object but may be flattened to a set of <code>UncertainValue</code> objects because this is what people feel comfortable with.  If subsequent calculations are to be performed, the result should definitely be maintained as an <code>UncertainValues</code> objects so as not to lose information about the correlations between the output parameters.</p><p>This library then implements methods to propagate uncertainties from input values to the output values using either the Monte Carlo strategy in GUM 101 or the first-order Taylor series approximation strategy in GUM 102.  They are complementary.  The Monte Carlo strategy is usually easier to implement and can handle variables with arbitrary input distributions.  The Taylor series approach requires analytical partial derivatives (or numerical approximations) but is typically much faster and allows contributions to be tracked from input values to output values.  The library makes it easy to compare results from the Monte Carlo and Taylor series approaches.  They don&#39;t always agree (for various reasons) but they often do.  When they don&#39;t agree it suggests that maybe the first-order Taylor series approximation is insufficient.</p><p>The identity of input and output values must be rigorously tracked.  Input values must be entered once and only once.  Intermediate values must be computed once and only once.  While it might be possible to use <code>Symbol</code> objects for simple models, more complex models may require a more sophisticated mechanism to label quantities.  For this purpose, a <code>Label</code> abstract class has been constructed with a <code>BasicLabel</code> implementation to handle simple labels and an <code>nl&quot;???&quot;</code> macro to create a string-based label.</p><p>A collection of <code>Label</code> structures and the associated <code>Float64</code> values can be collected in a <code>LabeledValues</code> structure.  This structure provides a mechanism for mapping between <code>Label</code>, integer row/column index (in the covariance matrix) and the value.</p><p>To propagate values, you&#39;ll need to implement the abstract type <code>MeasurementModel</code> and a single method <code>compute(mm::MeasurementModel, inputs::LabeledValues, withJac::Bool)::MMResult</code>, which returns <code>MMResult = Tuple{LabeledValues, Union{Missing,AbstractMatrix{Float64}}}</code>.</p><p><code>compute(...)</code> is responsible for calculating two distinct objects.  The first item is the output <code>LabeledValues</code> structure and the second is a Jacobian matrix. The <code>LabeledValues</code> are the result values from the model and the Jacobian is a matrix of partial derivatives of the output quantities relative to the input quantities. The rows are labeled by the indices in the <code>inputs</code> variable and the columns are labeled by the result <code>LabeledValues</code>.</p><p>Let&#39;s consider an model with input variables <code>nl&quot;A&quot;</code>, <code>nl&quot;B&quot;</code>, and <code>nl&quot;C&quot;</code> and output variables <code>nl&quot;D&quot;</code>, <code>nl&quot;E&quot;</code>, <code>nl&quot;F&quot;</code> and <code>nl&quot;G&quot;</code>. (<code>nl&quot;A&quot;</code> is equivalent to <code>label(&quot;A&quot;)</code>).</p><pre><code class="language-julia hljs">timeme=true
using NeXLUncertainties
using BenchmarkTools

# Give our model a name and option parameters or flavor
struct TestMeasurementModel &lt;: MeasurementModel
    k::Float64  # Some useful value passed in but without an associated uncertainty
end

dd(a, b, c) = a + b^2 + c^3
ee(a, b, c) = log(a) + exp(c)
ff(a, b, c) = 3.2 * a * b * c
gg(a, b, c, k) = k * a * b + 1.8 * a * c

function NeXLUncertainties.compute(mm::TestMeasurementModel, inputs::LabeledValues, withJac::Bool=false)::MMResult
    # Build labels to identify the input variables.
    la, lb, lc = label.(( &quot;A&quot;, &quot;B&quot;, &quot;C&quot;))
    # Pluck the value associated with these labels from `inputs`
    a, b, c = inputs[la], inputs[lb], inputs[lc]
    # Build labels to identify the output values
    outlabels = label.(( &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot; ))
    # Calculate the output values
    results = ( dd(a, b, c), ee(a, b, c), ff(a, b, c), gg(a, b, c, mm.k) )
    # Build the `LabeledValues` to represent the result values
    outputs = LabeledValues(outlabels, results)
    # Note: The order of the label in the constructor decides their index
    @assert all(indexin(outputs, outlabels[i])==i for i in eachindex(outlabels))
    if withJac # Only compute the Jacobian if `withJac=true`
        # Compute the Jacobian column-by-column (input-by-input)
        jac = zeros(length(outputs), length(inputs))
        # Being very explicit...
        jac[indexin(outputs, label(&quot;D&quot;)), indexin(inputs, la)] = 1 # D[a+b^2+c^3,a]
        jac[indexin(outputs, label(&quot;E&quot;)), indexin(inputs, la)] = 1/a # D[log(a)+exp(c), a]
        jac[indexin(outputs, label(&quot;F&quot;)), indexin(inputs, la)] = 3.2*b*c # D[3.2*a*b*c, a]
        jac[indexin(outputs, label(&quot;G&quot;)), indexin(inputs, la)] = mm.k * b + 1.8 * c # D[mm.k * a * b + 1.8 * a * c, a]
        # Or relying on the order implied by `outlabels` used to construct `outputs`
        jac[:, indexin(inputs, lb)] .= ( 2.0 * b, 0, results[3] / b, mm.k * a )
        jac[:, indexin(inputs, lc)] .= ( 3.0 * c^2, exp(c), results[3] / c, 1.8 * a )
    else
        jac = missing
    end
    return (outputs, jac)
end</code></pre><p>That&#39;s it.  We can control the order of the output variables (within the <code>compute</code> function). However, in general, we can&#39;t control the order of the input variables so we do need to use the <code>indexin(...)</code> function to find the index of the input variables so that we place the Jacobian elements in the correct columns.</p><p>To perform the calculation, we don&#39;t use <code>compute(...)</code> directly.  Instead, we&#39;ll use the <code>(::MeasurementModel)(...)</code> notation. The input for these methods is an <code>UncertainValues</code> object.</p><p>Let&#39;s construct an <code>UncertainValues</code> object.</p><pre><code class="language-julia hljs">labels = [label(&quot;A&quot;), label(&quot;B&quot;), label(&quot;C&quot;)]
a, b, c = 2.0, π / 8, -1.0  # values
da, db, dc = 0.1, π / 40, 0.05 # uncertainties
cab, cac, cbc = -0.3, 0.8, 0.1 # correlation coefficients

values = [a, b, c]
covars = [
    da^2            cab * da * db       cac * da * dc
    cab * da * db        db^2           cbc * db * dc
    cac * da * dc   cbc * db * dc           dc^2
]
# Construct the UncertainValues object
inputs = uvs(labels, values, covars)</code></pre><table><tr><th style="text-align: left">Labels</th><th style="text-align: center">Values</th><th style="text-align: center"></th><th style="text-align: center">A</th><th style="text-align: center">B</th><th style="text-align: center">C</th></tr><tr><td style="text-align: left">A</td><td style="text-align: center">2.00e+00</td><td style="text-align: center"></td><td style="text-align: center">(1.00e-01)²</td><td style="text-align: center">-2.36e-03</td><td style="text-align: center">4.00e-03</td></tr><tr><td style="text-align: left">B</td><td style="text-align: center">3.93e-01</td><td style="text-align: center">±</td><td style="text-align: center">-2.36e-03</td><td style="text-align: center">(7.85e-02)²</td><td style="text-align: center">3.93e-04</td></tr><tr><td style="text-align: left">C</td><td style="text-align: center">-1.00e+00</td><td style="text-align: center"></td><td style="text-align: center">4.00e-03</td><td style="text-align: center">3.93e-04</td><td style="text-align: center">(5.00e-02)²</td></tr></table><p>Now construct and apply the model using function-like syntax.</p><pre><code class="language-julia hljs">model = TestMeasurementModel(2.3)
if timeme
    @btime model(inputs)
end
result = model(inputs)</code></pre><pre><code class="nohighlight hljs">5.940 μs (122 allocations: 6.42 KiB)</code></pre><table><tr><th style="text-align: left">Labels</th><th style="text-align: center">Values</th><th style="text-align: center"></th><th style="text-align: center">D</th><th style="text-align: center">E</th><th style="text-align: center">F</th><th style="text-align: center">G</th></tr><tr><td style="text-align: left">D</td><td style="text-align: center">1.15e+00</td><td style="text-align: center"></td><td style="text-align: center">(2.42e-01)²</td><td style="text-align: center">1.44e-02</td><td style="text-align: center">-1.91e-02</td><td style="text-align: center">4.13e-02</td></tr><tr><td style="text-align: left">E</td><td style="text-align: center">1.06e+00</td><td style="text-align: center">±</td><td style="text-align: center">1.44e-02</td><td style="text-align: center">(6.56e-02)²</td><td style="text-align: center">5.82e-03</td><td style="text-align: center">-4.74e-05</td></tr><tr><td style="text-align: left">F</td><td style="text-align: center">-2.51e+00</td><td style="text-align: center"></td><td style="text-align: center">-1.91e-02</td><td style="text-align: center">5.82e-03</td><td style="text-align: center">(4.57e-01)²</td><td style="text-align: center">-1.79e-01</td></tr><tr><td style="text-align: left">G</td><td style="text-align: center">-1.79e+00</td><td style="text-align: center"></td><td style="text-align: center">4.13e-02</td><td style="text-align: center">-4.74e-05</td><td style="text-align: center">-1.79e-01</td><td style="text-align: center">(4.21e-01)²</td></tr></table><p>As we expect, the outputs are <code>nl&quot;D&quot;</code> to <code>nl&quot;F&quot;</code> as an <code>UncertainValues</code> object.</p><p>Now imagine that you don&#39;t want to perform the full uncertainty calculation but just want to evaluate the model as though it were a regular function. This time construct a <code>LabeledValues</code> structure with the labels and values we defined above and apply the model using function-like syntax.</p><pre><code class="language-julia hljs">inputs = LabeledValues(labels, values)
if timeme
    @btime model(inputs)
end
result = model(inputs)</code></pre><pre><code class="nohighlight hljs">1.130 μs (26 allocations: 1.81 KiB)
LabeledValues[
	D =&gt; 1.1542125687670213
	E =&gt; 1.0610266217313877
	F =&gt; -2.5132741228718345
	G =&gt; -1.7935842241858693
]</code></pre><p>You might have noticed the <code>withJac=false</code> argument to the <code>compute(...)</code> function. It serves to short-circuit the computation of the Jacobian when it isn&#39;t necessary. A beauty of Julia is that by defining it with a default argument, the code compiles into two functions - one that computes the Jacobian and the other that doesn&#39;t.  Thus the simple evaluation of values (as immediately above) uses a function that doesn&#39;t even consider constucting the Jacobian and so is lean and fast.</p><p>This efficiency is important when we want to use the same function for a Monte Carlo propagation.</p><pre><code class="language-julia hljs">inputs = uvs(labels, values, covars)
if timeme
    @btime mcpropagate(model, inputs, 10000, parallel = false)
    @btime mcpropagate(model, inputs, 10000, parallel = true)
end
mcres = mcpropagate(model, inputs, 10000, parallel = false)</code></pre><pre><code class="nohighlight hljs">43.856 ms (760259 allocations: 41.82 MiB)
  42.179 ms (760259 allocations: 41.82 MiB)</code></pre><table><tr><th style="text-align: left">Labels</th><th style="text-align: center">Values</th><th style="text-align: center"></th><th style="text-align: center">D</th><th style="text-align: center">E</th><th style="text-align: center">F</th><th style="text-align: center">G</th></tr><tr><td style="text-align: left">D</td><td style="text-align: center">1.15e+00</td><td style="text-align: center"></td><td style="text-align: center">(2.43e-01)²</td><td style="text-align: center">1.45e-02</td><td style="text-align: center">-1.67e-02</td><td style="text-align: center">3.94e-02</td></tr><tr><td style="text-align: left">E</td><td style="text-align: center">1.06e+00</td><td style="text-align: center">±</td><td style="text-align: center">1.45e-02</td><td style="text-align: center">(6.61e-02)²</td><td style="text-align: center">6.42e-03</td><td style="text-align: center">-4.85e-04</td></tr><tr><td style="text-align: left">F</td><td style="text-align: center">-2.50e+00</td><td style="text-align: center"></td><td style="text-align: center">-1.67e-02</td><td style="text-align: center">6.42e-03</td><td style="text-align: center">(4.56e-01)²</td><td style="text-align: center">-1.78e-01</td></tr><tr><td style="text-align: left">G</td><td style="text-align: center">-1.79e+00</td><td style="text-align: center"></td><td style="text-align: center">3.94e-02</td><td style="text-align: center">-4.85e-04</td><td style="text-align: center">-1.78e-01</td><td style="text-align: center">(4.20e-01)²</td></tr></table><p>Due to the stochastic nature of the evaluation, the values and the covariance matrix are not precisely the same as the analytical evaluation but they are close.  As we like to say, &quot;good enough for government work.&quot;</p><p>This is enough for a &quot;Getting Started Page&quot; but if you remain interested, there are more topics to cover.  An important one is propagating errors for measurement models that are too complex to compute in a single step.  If the model can be broken into sequential steps - <code>step1</code>, <code>step2</code>, <code>step3</code> - it is possible to compose the steps to get the equivalent of <code>step3(step2(step1(inputs)))</code> using the compose operator <code>∘</code> as <code>(step3∘step2∘step1)(inputs)</code>. If it is possible to calculate the Jacobian for each step, it is possible to perform the propagation even if the Jacobian of the full calculation is too complex to compute directly.</p><p>Along the way, you may have noticed that error propagation in multivariate models is actually no more difficult than propagation in univariate models. This is particularly true if you attempt to apply the classic Freshman science rule (like <a href="https://en.wikipedia.org/wiki/Propagation_of_uncertainty#Example_formulae">these</a>) which only serve to give error propagation a bad name.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../composing/">Composing Multi-Step Models »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 30 December 2021 12:14">Thursday 30 December 2021</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
