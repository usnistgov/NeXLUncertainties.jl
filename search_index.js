var documenterSearchIndex = {"docs":
[{"location":"gettingstarted/#Getting-Started-with-NeXLUncertainies.jl","page":"Getting Started","title":"Getting Started with NeXLUncertainies.jl","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Uncertainty calculations can separated into univariate and multivariate cases depending upon the number of output quantities.  The univariate case is often handled using the strategies described in JCGM GUM 100 - Guide to the Expression of Uncertainty in Measurement and presented in many an undergraduate science class.  This technique can track uncertainties in multiple input quantities into the output value.  This strategy is well implemented in the Measurements.jl package.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"However, if your problem involves multiple outputs from one or more inputs, there will be correlations in the outputs that aren't handled in the univariate case.  X-ray microanalysis is an example of such a measurement model.  The inputs are k-ratios, ratios of X-ray intensity measured on a known and unknown material.  The outputs are the mass fractions of each element.  You can't measure one element at a time.  You must measured them all because the k-ratio for element A is a function of all the other elements in the material due to \"matrix effects\". So the mass fraction of element C_i is actually a function of all the ks.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"The multivariate case can be handled using strategies in JCGM GUM 101 - Evaluation of measurement data — Supplement 1 to the “Guide to the expression of uncertainty in measurement” — Propagation of distributions using a Monte Carlo method or JCGM GUM 102 - Evaluation of measurement data – Supplement 2 to the \"Guide to the expression of uncertainty in measurement\" – Extension to any number of output quantities.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"There isn't another library to handle the multivariate case, so this is it.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"This library defines two structures to hold quantities with associated uncertainties. A single value with an associate uncertainty is represented by an UncertainValue.  Multiple values, their uncertainties and the correlations between the values are represented by an UncertainValues (plural) structure. Internally, an UncertainValues object is represented by a Vector{Float64} and the covariance matrix by a Matrix{Float64}.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Often, the inputs to a calculation are represented by UncertainValue objects, while the calculation is progressing the values are tracked using UncertainValues objects and at the end of the calculation, the result is best expressed as an UncertainValues object but may be flattened to a set of UncertainValue objects because this is what people feel comfortable with.  If subsequent calculations are to be performed, the result should definitely be maintained as an UncertainValues objects so as not to lose information about the correlations between the output parameters.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"This library then implements methods to propagate uncertainties from input values to the output values using either the Monte Carlo strategy in GUM 101 or the first-order Taylor series approximation strategy in GUM 102.  They are complementary.  The Monte Carlo strategy is usually easier to implement and can handle variables with arbitrary input distributions.  The Taylor series approach requires analytical partial derivatives (or numerical approximations) but is typically much faster and allows contributions to be tracked from input values to output values.  The library makes it easy to compare results from the Monte Carlo and Taylor series approaches.  They don't always agree (for various reasons) but they often do.  When they don't agree it suggests that maybe the first-order Taylor series approximation is insufficient.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"The identity of input and output values must be rigorously tracked.  Input values must be entered once and only once.  Intermediate values must be computed once and only once.  While it might be possible to use Symbol objects for simple models, more complex models may require a more sophisticated mechanism to label quantities.  For this purpose, a Label abstract class has been constructed with a BasicLabel implementation to handle simple labels and an nl\"???\" macro to create a string-based label.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"A collection of Label structures and the associated Float64 values can be collected in a LabeledValues structure.  This structure provides a mechanism for mapping between Label, integer row/column index (in the covariance matrix) and the value.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"To propagate values, you'll need to implement the abstract type MeasurementModel and a single method compute(mm::MeasurementModel, inputs::LabeledValues, withJac::Bool)::MMResult, which returns MMResult = Tuple{LabeledValues, Union{Missing,AbstractMatrix{Float64}}}.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"compute(...) is responsible for calculating two distinct objects.  The first item is the output LabeledValues structure and the second is a Jacobian matrix. The LabeledValues are the result values from the model and the Jacobian is a matrix of partial derivatives of the output quantities relative to the input quantities. The rows are labeled by the indices in the inputs variable and the columns are labeled by the result LabeledValues.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Let's consider an model with input variables nl\"A\", nl\"B\", and nl\"C\" and output variables nl\"D\", nl\"E\", nl\"F\" and nl\"G\". (nl\"A\" is equivalent to label(\"A\")).","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"timeme=true\nusing NeXLUncertainties\nusing BenchmarkTools\n\n# Give our model a name and option parameters or flavor\nstruct TestMeasurementModel <: MeasurementModel\n    k::Float64  # Some useful value passed in but without an associated uncertainty\nend\n\ndd(a, b, c) = a + b^2 + c^3\nee(a, b, c) = log(a) + exp(c)\nff(a, b, c) = 3.2 * a * b * c\ngg(a, b, c, k) = k * a * b + 1.8 * a * c\n\nfunction NeXLUncertainties.compute(mm::TestMeasurementModel, inputs::LabeledValues, withJac::Bool=false)::MMResult\n    # Build labels to identify the input variables.\n    la, lb, lc = label.(( \"A\", \"B\", \"C\"))\n    # Pluck the value associated with these labels from `inputs`\n    a, b, c = inputs[la], inputs[lb], inputs[lc]\n    # Build labels to identify the output values\n    outlabels = label.(( \"D\", \"E\", \"F\", \"G\" ))\n    # Calculate the output values\n    results = ( dd(a, b, c), ee(a, b, c), ff(a, b, c), gg(a, b, c, mm.k) )\n    # Build the `LabeledValues` to represent the result values\n    outputs = LabeledValues(outlabels, results)\n    # Note: The order of the label in the constructor decides their index\n    @assert all(indexin(outlabels[i],outputs)==i for i in eachindex(outlabels))\n    if withJac # Only compute the Jacobian if `withJac=true`\n        # Compute the Jacobian column-by-column (input-by-input)\n        jac = zeros(length(outputs), length(inputs))\n        # Being very explicit...\n        jac[indexin(label(\"D\"),outputs), indexin(la, inputs)] = 1 # D[a+b^2+c^3,a]\n        jac[indexin(label(\"E\"),outputs), indexin(la, inputs)] = 1/a # D[log(a)+exp(c), a]\n        jac[indexin(label(\"F\"),outputs), indexin(la, inputs)] = 3.2*b*c # D[3.2*a*b*c, a]\n        jac[indexin(label(\"G\"),outputs), indexin(la, inputs)] = mm.k * b + 1.8 * c # D[mm.k * a * b + 1.8 * a * c, a]\n        # Or relying on the order implied by `outlabels` used to construct `outputs`\n        jac[:, indexin(lb, inputs)] .= ( 2.0 * b, 0, results[3] / b, mm.k * a )\n        jac[:, indexin(lc, inputs)] .= ( 3.0 * c^2, exp(c), results[3] / c, 1.8 * a )\n    else\n        jac = missing\n    end\n    return (outputs, jac)\nend","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"That's it.  We can control the order of the output variables (within the compute function). However, in general, we can't control the order of the input variables so we do need to use the indexin(...) function to find the index of the input variables so that we place the Jacobian elements in the correct columns.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"To perform the calculation, we don't use compute(...) directly.  Instead, we'll use the (::MeasurementModel)(...) notation. The input for these methods is an UncertainValues object.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Let's construct an UncertainValues object.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"labels = [label(\"A\"), label(\"B\"), label(\"C\")]\na, b, c = 2.0, π / 8, -1.0  # values\nda, db, dc = 0.1, π / 40, 0.05 # uncertainties\ncab, cac, cbc = -0.3, 0.8, 0.1 # correlation coefficients\n\nvalues = [a, b, c]\ncovars = [\n    da^2            cab * da * db       cac * da * dc\n    cab * da * db        db^2           cbc * db * dc\n    cac * da * dc   cbc * db * dc           dc^2\n]\n# Construct the UncertainValues object\ninputs = uvs(labels, values, covars)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Labels Values  A B C\nA 2.00e+00  (1.00e-01)² -2.36e-03 4.00e-03\nB 3.93e-01 ± -2.36e-03 (7.85e-02)² 3.93e-04\nC -1.00e+00  4.00e-03 3.93e-04 (5.00e-02)²","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Now construct and apply the model using function-like syntax.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"model = TestMeasurementModel(2.3)\nif timeme\n    @btime model(inputs)\nend","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"5.733 μs (87 allocations: 5.73 KiB)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"result = model(inputs)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Labels Values  D E F G\nD 1.15e+00  (2.42e-01)² 1.44e-02 -1.91e-02 4.13e-02\nE 1.06e+00 ± 1.44e-02 (6.56e-02)² 5.82e-03 -4.74e-05\nF -2.51e+00  -1.91e-02 5.82e-03 (4.57e-01)² -1.79e-01\nG -1.79e+00  4.13e-02 -4.74e-05 -1.79e-01 (4.21e-01)²","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"As we expect, the outputs are nl\"D\" to nl\"F\" as an UncertainValues object.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Now imagine that you don't want to perform the full uncertainty calculation but just want to evaluate the model as though it were a regular function. This time construct a LabeledValues structure with the labels and values we defined above and apply the model using function-like syntax.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"inputs = LabeledValues(labels, values)\nif timeme\n    @btime model(inputs)\nend","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"989.900 ns (21 allocations: 1.61 KiB)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"result = model(inputs)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"LabeledValues[\n\tD => 1.1542125687670213\n\tE => 1.0610266217313877\n\tF => -2.5132741228718345\n\tG => -1.7935842241858693\n]","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"You might have noticed the withJac=false argument to the compute(...) function. It serves to short-circuit the computation of the Jacobian when it isn't necessary. A beauty of Julia is that by defining it with a default argument, the code compiles into two functions - one that computes the Jacobian and the other that doesn't.  Thus the simple evaluation of values (as immediately above) uses a function that doesn't even consider constucting the Jacobian and so is lean and fast.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"This efficiency is important when we want to use the same function for a Monte Carlo propagation.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"inputs = uvs(labels, values, covars)\nif timeme\n    @btime mcpropagate(model, inputs, 10000, parallel = false)\n    @btime mcpropagate(model, inputs, 10000, parallel = true)\nend","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"34.054 ms (580218 allocations: 39.99 MiB)\n  7.420 ms (580251 allocations: 40.00 MiB)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"mcres = mcpropagate(model, inputs, 10000, parallel = false)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Labels Values  D E F G\nD 1.15e+00  (2.41e-01)² 1.42e-02 -1.90e-02 4.06e-02\nE 1.06e+00 ± 1.42e-02 (6.51e-02)² 5.71e-03 -5.76e-05\nF -2.50e+00  -1.90e-02 5.71e-03 (4.54e-01)² -1.77e-01\nG -1.79e+00  4.06e-02 -5.76e-05 -1.77e-01 (4.19e-01)²","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Due to the stochastic nature of the evaluation, the values and the covariance matrix are not precisely the same as the analytical evaluation but they are close.  As we like to say, \"good enough for government work.\"","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"This is enough for a \"Getting Started Page\" but if you remain interested, there are more topics to cover.  An important one is propagating errors for measurement models that are too complex to compute in a single step.  If the model can be broken into sequential steps - step1, step2, step3 - it is possible to compose the steps to get the equivalent of step3(step2(step1(inputs))) using the compose operator ∘ as (step3∘step2∘step1)(inputs). If it is possible to calculate the Jacobian for each step, it is possible to perform the propagation even if the Jacobian of the full calculation is too complex to compute directly.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Along the way, you may have noticed that error propagation in multivariate models is actually no more difficult than propagation in univariate models. This is particularly true if you attempt to apply the classic Freshman science rule (like these) which only serve to give error propagation a bad name.","category":"page"},{"location":"methods/#Method-Documentation","page":"Methods","title":"Method Documentation","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"Modules = [NeXLUncertainties]","category":"page"},{"location":"methods/#NeXLUncertainties.AllInputs","page":"Methods","title":"NeXLUncertainties.AllInputs","text":"AllInputs <: MeasurementModel\n\nCarry over all of the input variables to the next step in a calculation.  Typically used in consort with a ParallelMeasurementModel when inputs to this step will also be required in subsequent steps.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLUncertainties.ComposedMeasurementModel","page":"Methods","title":"NeXLUncertainties.ComposedMeasurementModel","text":"ComposedMeasurementModel <: MeasurementModel\n\nA ComposedMeasurementModel is used when the output from step-i will be used in a subsequent step.  Favor ParallelMeasurementModel whenever a collection of MeasurementModels share the same inputs (or subsets of the same inputs) since the ParallelMeasurementModels can be run on multiple threads and the Jacobians can be concatenated rather than multiplied. ParallelMeasurementModels and ComposedMeasurementModels can be combined to produce efficient calculation models.\n\nThe final result of the ComposedMeasurementModel is the output of the final step.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLUncertainties.LabeledValues","page":"Methods","title":"NeXLUncertainties.LabeledValues","text":"LabeledValues\n\nA LabeledValues object represents an efficient way to deal with arrays of Labeled values (Float64). Each value is indexed via a Label so storing them in Vectors with be O(N) whereas storing the Label and value in a Dict is O(1).  However, storing them in a Dict loses the ordering which we would also like to retain. LabeledValues are O(1) while retaining the order of the labels.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLUncertainties.MaintainInputs","page":"Methods","title":"NeXLUncertainties.MaintainInputs","text":"MaintainInputs <: MeasurementModel\n\nCarry over a subset of the input variables to the next step in a calculation.  Typically used in consort with a ParallelMeasurementModel when inputs to this step will also be required in subsequent steps.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLUncertainties.MeasurementModel","page":"Methods","title":"NeXLUncertainties.MeasurementModel","text":"MeasurementModel\n\nMeasurementModel is an abstract type representing a vector function of a vector input with correlated uncertainties.  A MeasurementModel is responsible for calculating vector function outputs and the associated Jacobian matrix both evaluated at the input values.\n\nTo emphasize that a MeasurementModel represents a vector function that takes an UncertainValues object representing the input values into an UncertainValues object representing the output values, the function operator has been overloaded:\n\n(mm::MeasurementModel)(uvs::UncertainValues)::UncertainValues\n\nor\n\n(mm::MeasurementModel)(uvs::Dict{<:Label, UncertainValue})::UncertainValues\n\nThis helps you to think of a MeasurementModel as the equivalent of a function for UncertainValues.\n\nFurthermore, you can compose / pipe / chain MeasurementModels together to implement a multi-step calculation using the ∘ operator.  If mm1 and mm2 are MeasurementModels such that the inputs for mm2 come from mm1 (and the original inputs) then:\n\n(mm2 ∘ mm1)(inputs) = mm2(mm1(inputs))\n\nEquivalently, if mm3 and mm4 both take the same inputs they may be computed in parallel using:\n\n(mm3 | mm4)(inputs) = cat(mm3(inputs), mm4(inputs))\n\nYou can combine ∘ and | together like this:\n\n(mm2 ∘ (mm3 | mm4) ∘ mm1)(inputs) = mm2(cat(mm3(mm1(inputs)),mm4(mm1(inputs))))\n\nwhich first computes o1=mm1(inputs) then computes o3=mm3(inputs+o1) and o4=mm4(inputs+o1) finally  computes mm2(inputs+o1+o3+o4).\n\nComposing MeasurementModels is where the magic occurs. For a complex measurement model, it may not be feasible/possible to calculate an analytical form of the partial derivative. However, if the model can be broken into a series of smaller composable steps for which the analytical partial derivative can be calculated, the steps can be combined to build the full model.  Of course this isn't magic, it results from this property of Jacobians:\n\nmathbfJ_g(f(x)) _x = mathbfJ_g(y) _f(x) mathbfJ_f(x) _x\n\nTo use this framework on your measurement model, you must implement the function compute(...) for YourMeasurementModel.\n\ncompute(mm::YourMeasurementModel, inputs::LabeledValues, withJac::Boolean)::MMResult\n\nwhere\n\nMMResult = Tuple{LabeledValues, Union{Missing,AbstractMatrix{Float64}}}\n\nThe function compute(...) is responsible for computing the models output values and the Jacobian of the output values with respect to the input values.  The Jacobian is a matrix with one row per output value and one column per input value. The contents of the r,c-th element is the partial derivative of the r-th output value with respect to the c-th input value.\n\nMMResult represents the function output values (LabeledValues) and the Jacobian as an AbstractMatrix{Float64}.  To optimize the compute(...) function when used to simply compute the vector valued function, the Jacobian must calculated only when withJac=true.  If withJac=false then returning 'missing' for the Jacobian is encouraged.  This facilates efficiency when using 'compute(...)' in situations like Monte Carlo propagation (using mcpropagate(...)) where it is wasteful to compute the Jacobian but you'd otherwise like to use identical code to compute the function values.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLUncertainties.ParallelMeasurementModel","page":"Methods","title":"NeXLUncertainties.ParallelMeasurementModel","text":"ParallelMeasurementModel <: MeasurementModel\n\nA ParallelMeasurementModel is a collection of MeasurementModels that can be executed simultaneously since they share the same inputs (or a subset of the same inputs). ParallelMeasurementModels should be favored over ComposedMeasurementModels since they can be threaded and combining Jacobians is more computationally efficient.\n\nParallelMeasurementModel(models::AbstractVector{MeasurementModel}, multithread=false)\n\nWhile ParallelMeasurementModel supports multi-threading, multi-threading should be used only when the cost of the calculation is going to exceed the overhead necessary to create and manage the thread.  Usually this means, only use multithread=true on one of the outer-most steps of a large calculation where splitting the calculation can keep the Jacobians as small as possible until the last possible moment.\n\nThe result of the ParallelMeasurementModel is the union of the outputs from each model.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLUncertainties.UncertainValue","page":"Methods","title":"NeXLUncertainties.UncertainValue","text":"UncertainValue\n\nRepresents a floating point numerical value and an associated uncertainty (1σ).\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLUncertainties.UncertainValues","page":"Methods","title":"NeXLUncertainties.UncertainValues","text":"UncertainValues\n\nRepresents a set of related variables with the covariance matrix that represents the uncertainty relationships between the variables.\n\n\n\n\n\n","category":"type"},{"location":"methods/#Base.:|-Tuple{ParallelMeasurementModel,MeasurementModel}","page":"Methods","title":"Base.:|","text":"(|)(mm1::MeasurementModel, mm2::MeasurementModel)\n(^)(mm1::MeasurementModel, mm2::MeasurementModel)\n\nImplements a mechanism to combine MeasurementModels that work on the same input to produce output that is the combination of the outputs of all the measurement models.  This is useful when a calculation forks into 2 or more distinct calculations which are later composed as is shown in the examples.\n\nExamples:\n\nj = f | g # Creates a ParallelMeasurementModel([f,g], false)\njp = f ^ g # Creates a ParallelMeasurementModel([f,g], true)\ny = j(x) # where y combines the outputs of f(x) and h(x)\nz = (f | g | h)(x) # Conceptually like combine(f(x), g(x), h(x)) into a single output\nzp = (f ^ g ^ h)(x) # ParallelMeasurementModel([f,g,h], true)  Conceptually like combine(f(x), g(x), h(x)) into a single output\n(k ∘ (f | g | h))(x) == k(z) # Conceptually like k(f(x),g(x),h(x))\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.:∘-Tuple{ComposedMeasurementModel,MeasurementModel}","page":"Methods","title":"Base.:∘","text":"(∘)(mm1::MeasurementModel, mm2::MeasurementModel)\n\nImplements composition of MeasurementModels.\n\nExamples:\n\n(g ∘ f)(x) == propagate(ComposedMeasurementModel([f, g]), x)\n(g ∘ f)(x) == g(f(x))\n(h ∘ g ∘ f)(x) == propagate(ComposedMeasurementModel([f, g, h]), x)\n(h ∘ g ∘ f)(x) == h(g(f(x)))\n\nNote:\n\n(h ∘ (g ∘ f))(x) == ((h ∘ g) ∘ f)(x) == (h ∘ g ∘ f)(x)\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.cat-Tuple{AbstractArray{UncertainValues,N} where N}","page":"Methods","title":"Base.cat","text":"cat(uvss::AbstractArray{UncertainValues})::UncertainValues\n\nCombines the disjoint UncertainValues in uvss into a single UncertainValues object.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.cat-Tuple{Vararg{UncertainValues,N} where N}","page":"Methods","title":"Base.cat","text":"cat(uvss::UncertainValues...)::UncertainValues\n\nCombines the disjoint UncertainValues in uvss into a single UncertainValues object.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.filter-Tuple{AbstractArray{#s306,1} where #s306<:Label,Tuple{LabeledValues,Union{Missing, AbstractArray{Float64,2}}}}","page":"Methods","title":"Base.filter","text":"filter(labels::AbstractVector{<:Label}, mmr::MMResult)::MMResult\n\nTrims an MMResult down to only those labels in labels.  This can optimize calculations which are carrying a lot of intermediary results that are no longer needed.  All Jacobian input columns are maintained but only those output rows associated with a label in labels will be retained.  This method reorders the output values to match the order in labels.\n\nIf the input 'mmr' is N functions of M variables and length(labels)=P then the result will be P functions of M variables.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.filter-Tuple{UncertainValues,Array{#s302,1} where #s302<:Label}","page":"Methods","title":"Base.filter","text":"Base.filter(uvs::UncertainValues, labels::Vector{<:Label})::Matrix\n\nExtract the covariance matrix associated with the variables specified in labels into a Matrix.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.indexin-Tuple{Label,LabeledValues}","page":"Methods","title":"Base.indexin","text":"indexin(lbl::Label, lv::LabeledValues)::Int\n\nReturns the index associated with the specified Label.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.max-Tuple{UncertainValue,UncertainValue}","page":"Methods","title":"Base.max","text":"max(uv1::UncertainValue, uv2::UncertainValue)\n\nDetermines the maximum of two values by comparing first the value and second the uncertainty. (Equal value defer to the larger uncertainty being considered the 'max'.)\n\nIf value(uv1)==value(uv2) then it is undefined which is larger but to ensure a constant ordering I define the one with a larger uncertainty to be larger since it is more probable that it could be larger.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.min-Tuple{UncertainValue,UncertainValue}","page":"Methods","title":"Base.min","text":"min(uv1::UncertainValue, uv2::UncertainValue)\n\nDetermines the maximum of two values by comparing first the value and second the uncertainty. (Equal value defer to the larger uncertainty being considered the 'min'.)\n\nIf value(uv1)==value(uv2) then it is undefined which is smaller but to ensure a constant ordering I define the one with a larger uncertainty to be smaller since it is more probable that it could be smaller.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.values-Tuple{LabeledValues}","page":"Methods","title":"Base.values","text":"values(lv::LabeledValues)::Vector{Float64}\n\nA copy Vector of the values in order.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.values-Tuple{UncertainValues}","page":"Methods","title":"Base.values","text":"values(uvs::UncertainValues)::Vector{Float64}\n\nA Vector containing the Float64 value for each row in uvs.  In the same order as labels(uvs).\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.add-Tuple{Real,UncertainValue,Real,UncertainValue,AbstractFloat}","page":"Methods","title":"NeXLUncertainties.add","text":"add(ka::Real, a::UncertainValue, kb::Real, b::UncertainValue, cc::AbstractFloat)\n\nComputes ka*a + kb*b where a and b are UncertainValue and cc is the correlation coefficient defined as cc = covar(a,b)/( σ(a), σ(b) )\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.checkcovariance!","page":"Methods","title":"NeXLUncertainties.checkcovariance!","text":"checkcovariance!(cov::AbstractMatrix)\n\nChecks whether the matrix meets the criteria for a covariance matrix. (Square, non-negative diagonal elements, symmetric cov[r,c]==cov[c,r], and the correlation coefficient between -1.0 and 1.0).  The tests are approximate to handle rounding errors but when a symmetric pair of values are not precisely equal they are set equal and when the correlation coefficient is slightly outside [-1,1], it is restricted to within these bounds. Thus the input matrix can be modified, in ways that are probably benign, by this \"check\" function.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLUncertainties.compute-Tuple{MeasurementModel,LabeledValues}","page":"Methods","title":"NeXLUncertainties.compute","text":"compute(mm::MeasurementModel, uvs::LabeledValues)::LabeledValues\n\nCalculate the output values for the specified set of input LabeledValues.\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.correlation-Tuple{Label,Label,UncertainValues}","page":"Methods","title":"NeXLUncertainties.correlation","text":"correlation(a::Label, b::Label, uvs::UncertainValues)\n\nReturns the Pearson correlation coefficient between variables a and b.\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.covariance-Tuple{Label,Label,UncertainValues}","page":"Methods","title":"NeXLUncertainties.covariance","text":"covariance(lbl1::Label, lbl2::Label, uvs::UncertainValues)\n\nThe covariance between the two variables.\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.covariance-Tuple{UncertainValue,UncertainValue,Real}","page":"Methods","title":"NeXLUncertainties.covariance","text":"covariance(uv1::UncertainValue, uv2::UncertainValue, correlation::Real)\n\nComputes the covariance given the correlation coefficient between two UncertainValue.\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.divide-Tuple{UncertainValue,UncertainValue,AbstractFloat}","page":"Methods","title":"NeXLUncertainties.divide","text":"divide(n::UncertainValue, d::UncertainValue, cc::AbstractFloat)\n\nComputes n/d where n and d are UncertainValue and cc is the correlation coefficient defined as cc = covar(n,d)/( σ(n), σ(d) )\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.equivalent","page":"Methods","title":"NeXLUncertainties.equivalent","text":"equivalent(A::UncertainValue, B::UncertainValue, k=1.0)\n\nA and B are equivalent if |A-B| <= k σ(A-B)\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLUncertainties.estimated-Tuple{Array{#s304,1} where #s304<:Label,Array{Float64,2}}","page":"Methods","title":"NeXLUncertainties.estimated","text":"estimated(labels::Vector{<:Label}, samples::Matrix{Float64})\n\nEstimate an UncertainValues based on a set of samples ('measurements'). Computes the mean values and the covariance matrix from the expectation values. Each row r in samples represents a measured quantity as identified by labels[r]. Each column represents a single set of measurements of all the labeled quantities.\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.fractional-Tuple{Real}","page":"Methods","title":"NeXLUncertainties.fractional","text":"fractional(f::Real)\n\nReturns 0\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.fractional-Tuple{UncertainValue}","page":"Methods","title":"NeXLUncertainties.fractional","text":"fractional(uv::UncertainValue)\n\nComputes the fractional uncertainty.\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.labeledvalues-Tuple{UncertainValues}","page":"Methods","title":"NeXLUncertainties.labeledvalues","text":"labeledvalues(uvs::UncertainValues)\n\nConverts the values of an UncertainValues object into a LabeledValues object.\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.labels-Tuple{LabeledValues}","page":"Methods","title":"NeXLUncertainties.labels","text":"labels(lv::LabeledValues)::Vector{Label}\n\nA Vector of the Labels in order.\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.labels-Tuple{UncertainValues}","page":"Methods","title":"NeXLUncertainties.labels","text":"labels(uvs::UncertainValues)::Vector{<:Label}\n\nReturns a Vector of Label in the order in which they appear in uvs.values and uvs.covariance.\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.mcpropagate-Tuple{MeasurementModel,UncertainValues,Int64}","page":"Methods","title":"NeXLUncertainties.mcpropagate","text":"mcpropagate(mm::MeasurementModel, inputs::UncertainValues, n::Int, parallel::Bool=true, rng::AbstractRNG = Random.GLOBAL_RNG)::UncertainValues\n\nPropagate the inputs through the MeasurementModel using a MonteCarlo algorithm in which the inputs are assumed to be represented by a MvNormal distribution with covariance from inputs.  Performs 'n' iterations and multi-thread if parallel=true.\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.multiply-Tuple{UncertainValue,UncertainValue,AbstractFloat}","page":"Methods","title":"NeXLUncertainties.multiply","text":"multiply(a::UncertainValue, b::UncertainValue, cc::AbstractFloat)\n\nComputes a*b where a and b are UncertainValue and cc is the correlation coefficient defined as cc = covar(a,b)/( σ(a), σ(b) )\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.parallel-Tuple{MeasurementModel,Vararg{MeasurementModel,N} where N}","page":"Methods","title":"NeXLUncertainties.parallel","text":"parallel(mm1::MeasurementModel, models::MeasurementModel...)\n\nImplements a mechanism to combine MeasurementModels that work on the same input to produce output that is the combination of the outputs of all the measurement models.  This is useful when a calculation forks into 2 or more distinct calculations which are later composed as is shown in the examples.\n\nExamples:\n\nj = parallel(f,g) # Creates a ParallelMeasurementModel([f,g], true)\ny = j(x) # where y combines the outputs of f(x) and h(x)\nz = parallel(f, g, h)(x) # Conceptually like combine(f(x), g(x), h(x)) into a single output\n(k ∘ parallel(f, g, h))(x) == k(z) # Conceptually like k(f(x),g(x),h(x))\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.pearson-Tuple{UncertainValue,UncertainValue,Real}","page":"Methods","title":"NeXLUncertainties.pearson","text":"pearson(uv1::UncertainValue, uv2::UncertainValue, covar::Real)\n\nComputes the Pearson correlation coefficient given the covariance between two UncertainValue.\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.poisson-Tuple{Int64}","page":"Methods","title":"NeXLUncertainties.poisson","text":"poisson(val::Int)\n\nCreates an UncertainValue from an integer which is assumed to have σ = sqrt(val).\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.propagate-Tuple{MeasurementModel,UncertainValues}","page":"Methods","title":"NeXLUncertainties.propagate","text":"propagate(mm::MeasurementModel, uvs::UncertainValues)::UncertainValues\n\nPropagate the input (measured values as UncertainValues) through the MeasurementModel to produce the output values (as UncertainValues).\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.sortedlabels-Tuple{UncertainValues}","page":"Methods","title":"NeXLUncertainties.sortedlabels","text":"sortedlabels(uvs::UncertainValues)\n\nA alphabetically sorted list of the labels. Warning this can be slow.  Use keys(...) if you want just a unordered set of labels.\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.uncertainty","page":"Methods","title":"NeXLUncertainties.uncertainty","text":"uncertainty(uv::UncertainValue, k::Real=1.0)\n\nReturns the k-σ uncertainty (defaults to k=1.0)\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLUncertainties.uncertainty-2","page":"Methods","title":"NeXLUncertainties.uncertainty","text":"uncertainty(f::Real, k::Real=1.0)\n\nReturns 0.0.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLUncertainties.uncertainty-3","page":"Methods","title":"NeXLUncertainties.uncertainty","text":"uncertainty(lbl::Label, uvs::UncertainValues, k::Float64=1.0)\n\nThe uncertainty associated with specified label (k σ where default k=1)\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLUncertainties.uv-Tuple{Real,Real}","page":"Methods","title":"NeXLUncertainties.uv","text":"uv(val::Real, σ::Real)\n\nCreate an UncertainValue from a real value and 1σ uncertainty.\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.value-Tuple{Label,UncertainValues}","page":"Methods","title":"NeXLUncertainties.value","text":"value(lbl::Label, uvs::UncertainValues)\n\nThe value associate with the Label.\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.value-Tuple{LabeledValues,Label}","page":"Methods","title":"NeXLUncertainties.value","text":"value(lv::LabeledValues, lbl::Label)::Float64\n\nReturns the value associated with the specified Label.\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.value-Tuple{Real}","page":"Methods","title":"NeXLUncertainties.value","text":"value(f::Real)\n\nReturns f\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.value-Tuple{UncertainValue}","page":"Methods","title":"NeXLUncertainties.value","text":"value(uv::UncertainValue)\n\nReturns the value portion. (uv.value)\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.variance-Tuple{Label,UncertainValues}","page":"Methods","title":"NeXLUncertainties.variance","text":"variance(lbl::Label, uvs::UncertainValues)\n\nThe variance associated with the specified Label.\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.variance-Tuple{Real}","page":"Methods","title":"NeXLUncertainties.variance","text":"variance(f::Real)\n\nReturns 0.\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.variance-Tuple{UncertainValue}","page":"Methods","title":"NeXLUncertainties.variance","text":"variance(uv::UncertainValue)\n\nReturns σ².\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.σ-Tuple{Label,UncertainValues}","page":"Methods","title":"NeXLUncertainties.σ","text":"σ(lbl::Label, uvs::UncertainValues)\n\nReturns the 1σ uncertainty associated with the specified label\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.σ-Tuple{Real}","page":"Methods","title":"NeXLUncertainties.σ","text":"σ(r::Real)\n\nReturns 0.\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.σ-Tuple{UncertainValue}","page":"Methods","title":"NeXLUncertainties.σ","text":"σ(uv::UncertainValue)\n\nReturns the 1-σ uncertainty)\n\n\n\n\n\n","category":"method"},{"location":"methods/#Statistics.mean-Tuple{AbstractArray{UncertainValue,1}}","page":"Methods","title":"Statistics.mean","text":"Statistics.mean(uvs::UncertainValue...)\nStatistics.mean(uvs::AbstractVector{UncertainValue})\n\nThe variance weighted mean of a collection of UncertainValue items. (see https://en.wikipedia.org/wiki/Weightedarithmeticmean#Variance_weights).\n\n\n\n\n\n","category":"method"},{"location":"methods/#Statistics.std-Tuple{Vararg{UncertainValue,N} where N}","page":"Methods","title":"Statistics.std","text":"Statistics.std(uvs::UncertainValue...)\n\nThe standard deviation of the value portion of the collection of UncertainValue items.\n\n\n\n\n\n","category":"method"},{"location":"composing/#Composing-and-Parallelizing","page":"Composing Multi-Step Models","title":"Composing and Parallelizing","text":"","category":"section"},{"location":"composing/#Sequential-Steps","page":"Composing Multi-Step Models","title":"Sequential Steps","text":"","category":"section"},{"location":"composing/","page":"Composing Multi-Step Models","title":"Composing Multi-Step Models","text":"When one sits down to perform uncertainty propagation, it can be overwhelming. The measurement models can be complex.  The thought of computing the necessary partial derivatives can be intimidating.  However, many models can be factored into a series of simple steps - compute this and then compute that from this. Taken one-by-one, it is likely to be a lot easier to compute the partial derivatives for the simple steps than for the full model.","category":"page"},{"location":"composing/","page":"Composing Multi-Step Models","title":"Composing Multi-Step Models","text":"Fortunately, we have the chain-rule of differential calculus.  The chain rule says that","category":"page"},{"location":"composing/","page":"Composing Multi-Step Models","title":"Composing Multi-Step Models","text":"fracδf(g(x))δx = left fracδf(y)δyright _y=g(x) fracδg(x)δx","category":"page"},{"location":"composing/","page":"Composing Multi-Step Models","title":"Composing Multi-Step Models","text":"The key fact here is that we can break a complex problem into a series of simpler steps.  We don't need to compute fracδf(g(x))δx directly.  We can compute fracδf(y)δy and fracδg(x)δx and use the chain rule to compute fracδf(g(x))δx.","category":"page"},{"location":"composing/","page":"Composing Multi-Step Models","title":"Composing Multi-Step Models","text":"In the multivariate world, it gets even better. If F(X) and G(Y) are a vector functions of a vector variable and JF(X) and JG(Y) are the Jacobians of F(X) and G(Y) respectively then","category":"page"},{"location":"composing/","page":"Composing Multi-Step Models","title":"Composing Multi-Step Models","text":"JG(F(X)) = left JG(Y) right _Y=G(X) JF(X)","category":"page"},{"location":"composing/","page":"Composing Multi-Step Models","title":"Composing Multi-Step Models","text":"That is to say, if we compute the Jacobian matrix for each step, we can compute the Jacobian for the entire calculation by taking the product of the Jacobians. All the bookkeeping necessary handle all the variables is performed by matrix products.  This is far simpler than the univariate measurement model case outlined in the BIPM GUM. For comparison, consider equation 13 on page 21 of the GUM.  Equation 13 is exactly equivalent to the Jacobian expression in the univariate case but the bookkeeping is so much less clear.","category":"page"},{"location":"composing/","page":"Composing Multi-Step Models","title":"Composing Multi-Step Models","text":"The equivalent of equation 13 in the multivariate case is","category":"page"},{"location":"composing/","page":"Composing Multi-Step Models","title":"Composing Multi-Step Models","text":"U(F(X)) = JF(X) U(X) JF(X)^T","category":"page"},{"location":"composing/","page":"Composing Multi-Step Models","title":"Composing Multi-Step Models","text":"Clean, simple, straighforward.","category":"page"},{"location":"composing/","page":"Composing Multi-Step Models","title":"Composing Multi-Step Models","text":"From a practical perspective, this library allows you to implementing MeasurementModel types to represent each step in a calculation.  So let's say we implement measurement models MM1, MM2 and MM3.  The output of MM1 is a superset of the values required as input to MM2 and the output of MM2 is a superset of the values required as input to MM3. We can create an object to represent the composition of these models using the \"compose operator\" ∘ - MM1to3 = MM3 ∘ MM2 ∘ MM1. MM1to3(X) is conceptually equivalent to MM3(MM2(MM1(X))). (The ∘ operator is syntactic sugar for the ComposedMeasurementModel type.)","category":"page"},{"location":"composing/","page":"Composing Multi-Step Models","title":"Composing Multi-Step Models","text":"Like we did on the Getting Started page, it is possible to apply the composed MeasurementModel MM1to3 to either input represented by an UncertainValues object (the full uncertainty calculation) or a LabeledValues object (just the function evaluation). The computational cost of the entire calculation is roughly the sum of the cost of the individual steps plus the matrix products of the Jacobians.","category":"page"},{"location":"composing/","page":"Composing Multi-Step Models","title":"Composing Multi-Step Models","text":"One subtlety - sometimes it is necessary to pass variables unmodified from one step to the next.  This is of course handled trivially by the identity function with derivative of unity.  Since this is common, there is a special mechanism to handle this using the MaintainInputs or AllInputs MeasurementModels combined with the next concept - parallel steps.","category":"page"},{"location":"composing/","page":"Composing Multi-Step Models","title":"Composing Multi-Step Models","text":"See the \"Resistor Network Example\" for a (somewhat) simple multi-step computation.","category":"page"},{"location":"composing/#Parallel-Steps","page":"Composing Multi-Step Models","title":"Parallel Steps","text":"","category":"section"},{"location":"composing/","page":"Composing Multi-Step Models","title":"Composing Multi-Step Models","text":"In some measurement models, the same calculation is repeated on multiple sets of input data.  In this case, it is useful to be able to apply the same MeasurementModel to different sub-sets of the data.  For example, if you want to compute the X-ray mass absorption coefficient (MAC) for a series of different X-rays lines, you might define a generic MeasurementModel ComputeMAC that computes the MAC for a single X-ray line.  You could apply the model sequentially as described in \"sequential steps\".  However, it would often be more efficient to compute the MACs in parallel as a single step.","category":"page"},{"location":"composing/","page":"Composing Multi-Step Models","title":"Composing Multi-Step Models","text":"There are two operators to handle steps that can be calculated in parallel and combined to look like a single step = \"^\" and \"|\".  The first of these, \"^\", uses @threads to parallelize the calculation. The second performs the calculation sequentially.  If the calculation is simple and quick use \"|\".  If the calculation is longer and more complex, \"^\" may be faster depending upon the relative cost of the calculation and the cost of spinning up multiple threads.  \"|\" and \"^\" are syntactic sugar for the \"ParallelMeasurementModel\" type.","category":"page"},{"location":"composing/","page":"Composing Multi-Step Models","title":"Composing Multi-Step Models","text":"There is a second use for the \"|\" and \"^\" operators (or the ParallelMeasurementModel type) is to pass variables unmodified from one step to the next using the MaintainInputs and AllInputs MeasurementModel types.","category":"page"},{"location":"#NeXLUncertainties.jl","page":"Home","title":"NeXLUncertainties.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NeXLUncertainies is a library for propagating the uncertainty in multivariate measurement models. What does this mean?","category":"page"},{"location":"","page":"Home","title":"Home","text":"A measurement model is a way to transform the measured values into the desired output values.  A very simple measurement model would be the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"You measure a length in inches but need to transform the measured value by multiplying by 25.4 mm/inch to report in millimeters.\nSlightly more complex, you measure the length and width of a rectangle and need to report the area.","category":"page"},{"location":"","page":"Home","title":"Home","text":"These models are considered univariate because there is a single output value.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A multivariate measurement model is a model in which there are multiple outputs. (Image: Comparing univariate and multivariate measurement models)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A simple example of multivariate measurement model:","category":"page"},{"location":"","page":"Home","title":"Home","text":"You measure the length and width of a rectangle and need to report the area, the perimeter and the aspect ratio.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you have a model of the univariate type Measurements.jl is probably what you want.  If you have a model of the multivariate-type NeXLUncertainties might be a better choice.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Often the distinction doesn't matter.  However, if, in our simple multivariate example, the area, perimeter and aspect ratio are used in subsequent calculations, ignoring the correlations between these values is likely to mis-estimate the resulting uncertainty.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The distinctions can matter for X-ray microanalysis where many k-ratios are measured and many compositional metrics are reported.  In between, there is a complex measurement model that depends upon many measured inputs and many physical parameters.  Hence this library was developed as part of the NeXL collection of X-ray microanalysis algorithms.","category":"page"},{"location":"#Important-Types","page":"Home","title":"Important Types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are two ways to represent numbers with associated uncertainties in NeXLUncertainies","category":"page"},{"location":"","page":"Home","title":"Home","text":"UncertainValue - Represents a single quantity with associated uncertainty\nUncertainValues - Represents a collection of related quantities with the associated uncertainty relationships","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are two important utility types","category":"page"},{"location":"","page":"Home","title":"Home","text":"Label - Provides an abstract type for labels that uniquely identify and track quantities\nLabeledValues - A collection of Labeled quantities (no associated uncertainties)","category":"page"},{"location":"#UncertainValue","page":"Home","title":"UncertainValue","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An UncertainValue is a simple wrapper around a value and an associated variance. UncertainValue objects are often used as inputs to calculations or outputs from calculations as they are more \"user friendly\".","category":"page"},{"location":"","page":"Home","title":"Home","text":"Common operations:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> a = uv(1.2,0.1) # Creates an `UncertainValue`\r\n1.2 ± 0.1\r\njulia> σ(a)\r\n0.1\r\njulia> value(a)\r\n1.2\r\njulia> variance(a)\r\n0.01","category":"page"},{"location":"#Label","page":"Home","title":"Label","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Label is an abstract class that can represent either simple or complex mechanisms to uniquely identify quantities.   If a quantity is used in two part of a calculation, the way that we identify that these two values are related is   through the label.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> l = nl\"X\" # Constructs a String-based label\r\nX\r\njulia> m = label(12) # Constructs an Int-based label\r\n12","category":"page"},{"location":"#LabeledValues","page":"Home","title":"LabeledValues","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LabeledValues are like a dictionary mapping a Label into a quantity.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> lvs = LabeledValues( nl\"A\"=>3.4, nl\"B\"=>4.5, nl\"C\"=>5.6 )\r\nLabeledValues[\r\n      A => 3.4\r\n      B => 4.5\r\n      C => 5.6\r\n]\r\njulia> lvs[nl\"A\"]\r\n3.4","category":"page"},{"location":"#UncertainValues","page":"Home","title":"UncertainValues","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An UncertainValues represents a collection of Labeled quantities and the associated covariance matrix.   UncertainValues often represent the output of a measurement model (or calculation).  Each quantity in the UncertainValues object is identified by a unique Label to permit values, variances and covariances to be readily tracked.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> u1 = uvs([ nl\"A\", nl\"B\", nl\"C\"], [3.4, 4.5, 5.6], [ 0.01 0.001 0.0; 0.001 0.004 0.0; 0.0 0.0 0.009 ])\r\nVariable       Value              A           B           C\r\nA          | 3.4      |     |   0.01        0.001       0         |\r\nB          | 4.5      |     |   0.001       0.004       0         |\r\nC          | 5.6      |     |   0           0           0.009     |\r\njulia> u1[nl\"B\"]\r\n4.5 ± 0.063\r\njulia> covariance(nl\"A\",nl\"B\",u1)\r\n0.001\r\njulia> value(nl\"A\",u1)\r\n3.4\r\njulia> σ(nl\"A\",u1)\r\n0.1","category":"page"},{"location":"#Propagating-Uncertainties","page":"Home","title":"Propagating Uncertainties","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Implementations of the MeasurementModel abstract type provide the mechanism by which uncertainties are propagated. Types implementing the MeasurementModel type are responsible for implementing one method:","category":"page"},{"location":"","page":"Home","title":"Home","text":"compute(mm::YourMeasurementModel, inputs::LabeledValues, withJac::Boolean)::MMResult","category":"page"},{"location":"","page":"Home","title":"Home","text":"where","category":"page"},{"location":"","page":"Home","title":"Home","text":"MMResult = Tuple{LabeledValues, Union{Missing,AbstractMatrix{Float64}}}","category":"page"},{"location":"","page":"Home","title":"Home","text":"The compute(...) takes a LabeledValues object which defines where the model is to be evaluated.   It returns either a Tuple{LabeledValues, Missing} (if withJac==false) or a Tuple{LabeledValues, AbstractMatrix{Float64}} (if withJac==true).  The LabeledValues return value represents the measurement model evaluated at inputs. The AbstractMatrix{Float64} represents the Jacobian of the measurement model or the matrix of partial derivatives evaluated at inputs.  Users of the library are responsible for defining the necessary MeasurementModel types and the associated compute(...) functions.","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The pages in the left-hand menu will help you to get started. \"Getting Started\" provides an overview.  \"Resistor Network Example\" shows how to implement multi-step MeasurementModels and use function composition to join the steps into a complex measurement model. \"Composing Multi-Step Models\" provides additional insight into how to use the ∘, | and ^ binary operators to combine simple steps into complex calculations.","category":"page"},{"location":"resistors/#A-(Relatively)-Simple-Example","page":"Resistor Network Example","title":"A (Relatively) Simple Example","text":"","category":"section"},{"location":"resistors/#The-Uncertainty-in-a-Resistor-Network","page":"Resistor Network Example","title":"The Uncertainty in a Resistor Network","text":"","category":"section"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"Let's imaging that we have a resistor network that looks like this:","category":"page"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"(Image: Resistor Network)","category":"page"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"Let's assume that each resistor is known with ± 5% accuracy.  What is the effective resistance of the network and the associated uncertainty?","category":"page"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"using NeXLUncertainties","category":"page"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"First let's define a label to help us uniquely identify the resistors.  The integer indices will be those in the blue (input) and peach (intermediate) boxes on the diagram above.","category":"page"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"struct Resistor <: Label\n    index::Integer\nend\n\nBase.show(io::IO, r::Resistor) = print(io, \"R$(r.index)\")","category":"page"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"First, let's design the measurement model for the resistors in series. The resistance is just the sum of the resistors involved and the derivative is unity for these resistors and zero for the other resistors.","category":"page"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"struct Series <: MeasurementModel\n    resistors::Vector{Resistor}\n    outindex::Int\nend\n\nBase.show(io::IO, ss::Series) = print(io,\"Rmodel[$(ss.outindex)]\")\n\nfunction NeXLUncertainties.compute(ss::Series, inputs::LabeledValues, withJac::Bool=false)\n    resistance = sum(inputs[r] for r in ss.resistors)\n    vals = LabeledValues( (Resistor(ss.outindex ), ), ( resistance, ) )\n    if withJac\n        jac= zeros(1, length(inputs))\n        for r in ss.resistors\n            jac[1, indexin(r, inputs)] = 1.0\n        end\n    else\n        jac = nothing\n    end\n    return (vals, jac)\nend","category":"page"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"Then the model for the resistors in parallel.  The resistance is the reciprocal of the sum of reciprocals of the resistors involved.","category":"page"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"struct Parallel <: MeasurementModel\n    resistors::Vector{Resistor}\n    outindex::Integer\nend\n\nBase.show(io::IO, ss::Series) = print(io,\"Rmodel[$(ss.outindex)]\")\n\nfunction NeXLUncertainties.compute(ss::Parallel, inputs::LabeledValues, withJac::Bool=false)\n    resistance = 1.0/sum(1.0/inputs[r] for r in ss.resistors)\n    vals = LabeledValues( (Resistor(ss.outindex ), ), ( resistance, ) )\n    if withJac\n        jac = zeros(1, length(inputs))\n        for r in ss.resistors\n            jac[1, indexin(r,inputs)] = (resistance/inputs[r])^2\n        end\n    end\n    return (vals, jac)\nend","category":"page"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"We'll define the input resistors' properties.","category":"page"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"# Define the inital resistors\nresistor = Resistor.(1:7)\nresistance = [ 8.0, 2.0, 10.0, 1.0, 4.0, 12.0, 1.0 ]\ndresistance = (0.05*resistance).^2\ninputs = uvs(resistor,resistance,dresistance)","category":"page"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"Labels Values  R1 R2 R3 R4 R5 R6 R7\nR1 8.00e+00  (4.00e-01)² 0.00e+00 0.00e+00 0.00e+00 0.00e+00 0.00e+00 0.00e+00\nR2 2.00e+00  0.00e+00 (1.00e-01)² 0.00e+00 0.00e+00 0.00e+00 0.00e+00 0.00e+00\nR3 1.00e+01  0.00e+00 0.00e+00 (5.00e-01)² 0.00e+00 0.00e+00 0.00e+00 0.00e+00\nR4 1.00e+00 ± 0.00e+00 0.00e+00 0.00e+00 (5.00e-02)² 0.00e+00 0.00e+00 0.00e+00\nR5 4.00e+00  0.00e+00 0.00e+00 0.00e+00 0.00e+00 (2.00e-01)² 0.00e+00 0.00e+00\nR6 1.20e+01  0.00e+00 0.00e+00 0.00e+00 0.00e+00 0.00e+00 (6.00e-01)² 0.00e+00\nR7 1.00e+00  0.00e+00 0.00e+00 0.00e+00 0.00e+00 0.00e+00 0.00e+00 (5.00e-02)²","category":"page"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"Then we will define a model to descibe each step in the network resistor. In each step, I've defined the model as the Series or Parallel combination of the resistors plus AllInputs() | to pass the input variables from this step onto the next. (Putting AllInputs() up front maintains the ordering of variables.)","category":"page"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"r8 = AllInputs() | Series([resistor[1], resistor[2]], 8)\nr9 = AllInputs() | Parallel([Resistor(8), resistor[3]], 9)\nr10 = AllInputs() | Series([resistor[4], Resistor(9)], 10)\nr11 = AllInputs() | Parallel([resistor[5], resistor[6], Resistor(10)], 11)\nr12 = AllInputs() | Series([resistor[7], Resistor(11)], 12);","category":"page"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"ParallelMeasurementModel(MeasurementModel[AllInputs(), Rmodel[12]], false)","category":"page"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"Finally, we pull together the steps into the overall model using the ∘ or compose operator.","category":"page"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"model = r12 ∘ r11 ∘ r10 ∘ r9 ∘ r8\nres = model(inputs)","category":"page"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"Labels Values  R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12\nR1 8.00e+00  (4.00e-01)² 0.00e+00 0.00e+00 0.00e+00 0.00e+00 0.00e+00 0.00e+00 1.60e-01 4.00e-02 4.00e-02 4.44e-03 4.44e-03\nR2 2.00e+00  0.00e+00 (1.00e-01)² 0.00e+00 0.00e+00 0.00e+00 0.00e+00 0.00e+00 1.00e-02 2.50e-03 2.50e-03 2.78e-04 2.78e-04\nR3 1.00e+01  0.00e+00 0.00e+00 (5.00e-01)² 0.00e+00 0.00e+00 0.00e+00 0.00e+00 0.00e+00 6.25e-02 6.25e-02 6.94e-03 6.94e-03\nR4 1.00e+00  0.00e+00 0.00e+00 0.00e+00 (5.00e-02)² 0.00e+00 0.00e+00 0.00e+00 0.00e+00 0.00e+00 2.50e-03 2.78e-04 2.78e-04\nR5 4.00e+00  0.00e+00 0.00e+00 0.00e+00 0.00e+00 (2.00e-01)² 0.00e+00 0.00e+00 0.00e+00 0.00e+00 0.00e+00 1.00e-02 1.00e-02\nR6 1.20e+01 ± 0.00e+00 0.00e+00 0.00e+00 0.00e+00 0.00e+00 (6.00e-01)² 0.00e+00 0.00e+00 0.00e+00 0.00e+00 1.00e-02 1.00e-02\nR7 1.00e+00  0.00e+00 0.00e+00 0.00e+00 0.00e+00 0.00e+00 0.00e+00 (5.00e-02)² 0.00e+00 0.00e+00 0.00e+00 0.00e+00 2.50e-03\nR8 1.00e+01  1.60e-01 1.00e-02 0.00e+00 0.00e+00 0.00e+00 0.00e+00 0.00e+00 (4.12e-01)² 4.25e-02 4.25e-02 4.72e-03 4.72e-03\nR9 5.00e+00  4.00e-02 2.50e-03 6.25e-02 0.00e+00 0.00e+00 0.00e+00 0.00e+00 4.25e-02 (1.62e-01)² 2.63e-02 2.92e-03 2.92e-03\nR10 6.00e+00  4.00e-02 2.50e-03 6.25e-02 2.50e-03 0.00e+00 0.00e+00 0.00e+00 4.25e-02 2.63e-02 (1.70e-01)² 3.19e-03 3.19e-03\nR11 2.00e+00  4.44e-03 2.78e-04 6.94e-03 2.78e-04 1.00e-02 1.00e-02 0.00e+00 4.72e-03 2.92e-03 3.19e-03 (5.60e-02)² 3.13e-03\nR12 3.00e+00  4.44e-03 2.78e-04 6.94e-03 2.78e-04 1.00e-02 1.00e-02 2.50e-03 4.72e-03 2.92e-03 3.19e-03 3.13e-03 (7.51e-02)²","category":"page"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"To access the single uncertain value associated with the result:","category":"page"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"res[Resistor(12)]","category":"page"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"3 ± 0.075","category":"page"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"You might have noticed that this example is actually a univariate measurement model.  There is a simpler way to handle this model using the Measurements package.","category":"page"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"First let's define our model equations and check that they produce the same number as above.","category":"page"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"pp(a,b) = 1.0/(1.0/a+1.0/b)\npp(a,b,c) = 1.0/(1.0/a+1.0/b+1.0/c)\nss(a,b) = a + b\n\nss(1.0,pp(12.0,4.0,ss(1.0,pp(10.0,ss(2.0,8.0)))))","category":"page"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"3.0","category":"page"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"Yes, they do.  Now let's use Measurements to perform the same calculation. We'll define the resistances with uncertainties using Measurements simplified syntax and then we will use the same functions we just used above to compute the model using the values with uncertainties.","category":"page"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"using Measurements\n\nr1 = 8.0 ± 0.4\nr2 = 2.0 ± 0.1\nr3 = 10.0 ± 0.5\nr4 = 1.0 ± 0.05\nr5 = 4.0 ± 0.2\nr6 = 12.0 ± 0.6\nr7 = 1.0 ± 0.05\n\nss(r7,pp(r6,r5,ss(r4,pp(r3,ss(r2,r1)))))","category":"page"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"3.0 ± 0.075","category":"page"},{"location":"resistors/","page":"Resistor Network Example","title":"Resistor Network Example","text":"We do, in fact, get the same result. Take away - For univariate measurement models Measurements is easier.  For multivariate measurement models, NeXLUncertainies is necessary.","category":"page"}]
}
